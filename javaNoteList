项目名全部小写
包名全部小写
类名首字母大写，每个单词首字母大写
变量名首字母小写，每个单词首字母大写
方法名首字母小写，每个单词首字母大写
常量名全部大写
Java不提供无符号整数类型
标识符是区分大小写的
Java中的类名、变量名、方法名等标识符由数字、字母、下划线、$组成，不能以数字开头，不能使用Java关键字，更不能有空格
类名首字母大写，变量名、方法名首字母小写，常量名大写
一个实数常量的默认类型是double，无特殊要求时建议选择double类型
float型小数常量，需要在小数后加f或F
整数有确定的值，而小数的值是近似值
字符常量使用一对单引号('')括起来
Unicode码字符集的字符关系：0~9 < A~Z < a~z < 汉字
通过强制类型转换(int)'0',可以输出字符'0'的Unicode码值
Java中的逻辑型值只有true和false，不能用0和1代替，true和false是逻辑常量(小写)，是Java关键字
Java使用Unicode编码，所以变量名和变量值都可以使用汉字
类的属性未赋初值时，系统为其指定默认值
定义局部变量时如果没有赋初值，系统不会为其指定默认值，局部变量未初始化不能访问
JVM就是通过方法签名来识别方法的，方法的识别需要通过方法名和参数类型进行
方法重载判定条件是同名方法但方法签名不同，与方法返回值和参数名称无关
Java的static只能修饰类的成员，不能修饰局部变量
在一个类中，静态方法只能访问静态成员，非静态方法可以访问一切成员
Java静态方法中不允许调用非静态成员，因为对象在未创建前非静态的属性没有分配内存、一般方法也没有分配地址入口
静态方法中不能出现关键字this
一般方法可以访问类的所有成员，包括静态成员
类的main方法是static方法，所以main方法可以直接访问该类定义的静态方法，却不能直接访问类的非静态方法(需要通过对象名.方法名()格式访问)
直接在类中定义的代码块称为构造代码块，构造代码块先于构造器执行，可以多次被执行
static修饰的构造代码块称为静态代码块，静态代码块先于构造器和主方法执行，且只执行一次，静态代码块是特殊的构造代码块
内部类可以方便访问其外部类的private成员
建议使用倒序的域名作为包名
Java是单继承，也就是只有一个父类，所以关键字extends是第三人称单数
一个类的定义没有使用extends，系统默认该类继承Object类
子类不会主动调动父类中带参构造器，创建子类对象时需要在构造器中用super关键字调用父类的构造器，以便能够对从父类继承过来的属性初始化
当生成子类对象时，Java首先(隐式)调用父类的不带参数的构造器，生成父类的对象。接下来，继续执行子类的构造方法，生成子类对象
要想生成子类的对象，首先需要生成父类的对象，没有父类对象就没有子类对象
同包中，一个类(public类或默认权限类)的成员，除private成员外，其他权限修饰的成员允许被本包中的其他类访问或继承
父类与子类在不同包中时，父类的protected成员可以被子类继承，而默认权限的成员不能被子类继承
instanceof运算符是Java语言特有的运算符，用来在运行时判定某对象是否为特定类(或该特定类的子类)的一个实例
方法重写要求子类的方法类型与父类方法类型相同或者是父类子类型，并且该方法的名字、参数与父类相同
使用关键字final定义的变量即是常量，常量名大写并且定义时赋值
final修饰的方法为最终方法，不允许子类重写父类的final方法
上转型对象的实体是子类创建的，但是失去了子类新增的成员变量和成员方法。相当于按照父类模板刻制的子类对象，是子类对象的简化对象
上转型对象不能访问子类新增的成员，上转型对象可以访问子类继承或者屏蔽的类成员，上转型对象可以操作子类的继承的方法和重写的方法
假设子类重写了父类的静态方法fun()，则子类的fun()方法必须也是静态的。如果子类对象的上转型对象调用静态的fun()方法，不能调用子类重写的静态方法fun()，调用的是父类的静态fun()方法

import java.util.Random;
Random r = new Random();
//[0,1.0)区间的随机数
double d1 = r.nextDouble();
//[0,5)区间的随机数
int n1 = r.nextInt(5);
//[0,5.0)区间的随机数
double d2 = r.nextDouble() * 5;
//[0,10]区间的随机数
int n2 = r.nextInt(11);
//[1,9)区间的随机数
int n3 = r.nextInt(8) + 1;

使用double型参数的构造方法会产生精度丢失，建议使用字符串参数的构造方法BigDecimal(String val)
"0"与"#"都是占位符，区别是"0"占位符比实际数字的位数多时，实际数值不足的地方用0补上，"#"占位符比实际数字的位数多时，实际值不变
Arrays类提供了二分查找方法binarySearch，如果待查数组的数据是有序的，可以直接调用Arrays.binarySearch方法，如果待查数组的数据是无序的，可先调用sort方法进行排序，然后再进行二分查找
对于String对象，关系运算符"=="的作用与Object的equals方法相同，判定两个对象是否为同一个对象实体，String的equals方法则表示判定字符串的值相等
replace方法返回的是一个新字符串，对原字符串没有做替换
StringBuffer类的对象的实体内存空间可以自动变化，便于存放变化的字符串
Java的集合类大致可以分为三类：Set是无序不可重复的集合，List是有序可以重复的集合，Map是映射关系的集合
Set判定集合中两个元素是否相等，使用equals方法(不使用==)
HashSet集合中两个元素相等标准：equals判定结果为true，且hashCode值相同
HashSet集合中两个元素相等判定方法就是重写元素类的equals和hashCode方法
对于String型元素，TreeSet会自动为其排序，并且元素值唯一
顺序表与链表侧重点不同，理论上链表在添加和删除操作上效率高于顺序表